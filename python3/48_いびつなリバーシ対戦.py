#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 12 00:41:30 2021

@author: yulong

下記の問題をプログラミングしてみよう！
1 から N のプレイヤー番号が与えられた N 人でいびつなオセロの対戦をします。
盤面・ゲームをする人数・合計のターン数・各行動についての情報が与えられます。
盤面に穴の空いているマスは # ,何も置かれていないマスは . になっています。
プレイヤー達は、各行動ごとに次の操作をおこないます。

・ 盤面のマス(Y_i, X_i)に石をおく。既に相手の石が置かれている場合は相手の石を自分の石に置き換えます。
次に、縦横斜めに自分の石ではさんだ連続した穴の空いていないマスに自分の石を置きます。相手の石が置かれている場合は相手の石を自分の石に置き換えて、操作を終了します

操作を終えた後の盤面を出力してください。ただし、番号 i のプレイヤーの石のあるマスを i として出力してください。
なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

例えば、図 1 の状態から赤いマスに B さんが石を置くと、図 2 の状態になります。
図 3 の状態から赤いマスに C さんが石を置くと、図 4 の状態になります。
図 5 の状態から赤いマスに A さんが石を置くと、図 6 の状態になります。


図１

図２

図３

図４

図５

図６

▼　下記解答欄にコードを記入してみよう

入力される値
H W N n     
S_0     
...     
S_(H-1)     
p_1 Y_1 X_1        
...     
p_n Y_n X_n


・ 1 行目では、盤面の行数 H ,列数 W , プレイヤーの人数 N , 全プレイヤーの合計ターン数 n が与えられます。
・ 続く H 行のうち i 行目 (0 ≦ i < H) には、盤面の i 行目の文字をまとめた文字列 S_i が与えられ、 S_i の j 文字目は、盤面の i 行目の j 列目に書かれている文字を表します。
・ 続く n 行のうち i 行目 (1 ≦ i ≦ n) には、i 回目の操作で石を置く人のプレイヤー番号 p_i と、その人が石を置く座標 Y_i X_i が与えられます。

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
期待する出力
H 行での出力

条件
すべてのテストケースにおいて、以下の条件をみたします。

・ 1 ≦ H, W ≦ 20
・ 1 ≦ N ≦ 9
・ 1 ≦ n ≦ 100
・ 0 ≦ Y_i < H, 0 ≦ X_i < W
・ 1 ≦ p_i ≦ N
・ S は W 文字の文字列
・ S の各文字は '.' または '#'
・ S[Y_i][X_i] = '.'

入力例1
3 3 2 4
...
...
.#.
1 0 0
2 2 0
1 0 2
2 2 2

出力例1
111
...
2#2

入力例2
20 20 5 50
.....#..............
....................
....................
.#..................
#...................
.........#..........
........#.#.........
............#.......
....................
.....#..............
.#..................
....................
............#.......
....#...............
...................#
....................
.................#..
....................
....#...........#..#
...........#.#......
3 18 14
1 15 17
4 11 10
4 14 14
5 5 6
3 17 3
3 17 19
4 15 2
2 18 13
4 6 6
1 1 7
5 6 15
5 6 14
3 15 17
4 16 10
1 9 6
4 9 15
1 1 10
3 16 5
5 16 3
5 7 11
4 4 2
1 2 2
1 3 7
1 15 16
1 14 0
4 18 0
3 8 12
3 7 4
2 13 2
3 8 6
1 16 1
2 12 3
2 12 7
4 4 8
2 3 13
4 14 9
5 12 18
3 8 0
5 8 15
1 17 18
2 18 0
4 16 1
3 3 6
2 8 2
2 2 6
4 6 6
1 11 8
4 7 4
3 8 5

出力例2
.....#..............
.......1111.........
..1...211...........
.#....21.....2......
#.4443234....2......
..4433243#...2......
..444343#3#..255....
..3.433...35#2.5....
33333342222222.5....
.3224#33...3.2.4....
.#2.24433.3..2......
..23.244134..2......
..223224334.#2....5.
..2.#2.34.3..2......
1.4.24344443.24....#
..42.3.3..2.32..13..
.4253333333232333#3.
.2.33333333322333313
2...#........23.#..#
...........#.#......
"""

H, W, N, n = map(int, input().split())
s = [list(input()) for _ in range(H)]
points = [list(map(int, input().split())) for _ in range(n)]


def check_diagonal(x, y, s, player):
    for lr1 in range(-1, 2, 2):
        for lr2 in range(-1, 2, 2):
            i = 0
            while True:
                i += 1
                if (
                    x + i * lr1 < 0
                    or x + i * lr1 >= W
                    or y + i * lr2 < 0
                    or y + i * lr2 >= H
                ):
                    break
                if s[y + i * lr2][x + i * lr1] == player:
                    for j in range(1 + i):
                        s[y + j * lr2][x + j * lr1] = player
                    break
                if s[y + i * lr2][x + i * lr1] == "#":
                    break


def check_row(x, y, s, player):
    for lr in range(-1, 2, 2):
        i = 0
        while True:
            i += 1
            if x + i * lr < 0 or x + i * lr >= W:
                break
            if s[y][x + i * lr] == player:
                for j in range(1 + i):
                    s[y][x + j * lr] = player
                break
            if s[y][x + i * lr] == "#":
                break


def check_column(x, y, s, player):
    for lr in range(-1, 2, 2):
        i = 0
        while True:
            i += 1
            if y + i * lr < 0 or y + i * lr >= H:
                break
            if s[y + i * lr][x] == player:
                for j in range(1 + i):
                    s[y + j * lr][x] = player
                break
            if s[y + i * lr][x] == "#":
                break


for p, y, x in points:
    s[y][x] = p
    check_row(x, y, s, p)
    check_column(x, y, s, p)
    check_diagonal(x, y, s, p)


for y in range(H):
    for x in range(W):
        print(s[y][x], end="")
    print()