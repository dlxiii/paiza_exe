#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 11 23:25:53 2021

@author: yulong

下記の問題をプログラミングしてみよう！
盤面・石を置く回数・各操作で石を置くマスについての情報が与えられます。
はじめ、プレイヤーの石が置かれているマスは ＊ になっており、盤面に穴の空いているマスは # ,何も置かれていないマスは . になっています。
プレイヤーは次の操作を N 回繰り返します。

・ 盤面のマス ( Y_i, X_i ) に石を置き、縦横斜めに自分の石ではさんだ連続した穴の空いていないマスの間に自分の石を置く。
新たに置いた石によってさらに石が置けるようになった場合でもその時点で操作を終える。






操作を終えた後の盤面を出力してください。
なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

▼　下記解答欄にコードを記入してみよう

入力される値
H W N       
S_0     
...     
S_(H-1)     
Y_1 X_1     
...     
Y_N X_N


・ １行目では、盤面の行数 H ,列数 W , 石を置く回数 N が与えられます。
・ 続く H 行のうち i 行目 (0 ≦ i < H) には、盤面の i 行目の文字をまとめた文字列 S_i が与えられ、 S_i の j 文字目は、盤面の i 行目の j 列目に書かれている文字を表します。
・ 続く N 行のうち i 行目 (0 ≦ i ≦ N) には、i 回目の操作で石を置く座標 Y_i X_i が与えられます。

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
期待する出力
H 行での出力

条件
すべてのテストケースにおいて、以下の条件をみたします。

・ 1 ≦ H, W, N ≦ 20
・ 0 ≦ Y_i < H, 0 ≦ X_i < W
・ S は W 文字の文字列
・ S の各文字は '.' または '*' または '#'
・ S[Y_i][X_i] = '.'

入力例1
3 3 1
..*
...
*.*
0 0

出力例1
***
**.
*.*

入力例2
18 18 10
.........*........
....*..*..*.#.#..#
......**.#........
..#.....#.........
...#..............
.*..........*....*
#.................
...*.............#
..#.......*.......
..................
......*..........*
#.........*.......
.#..............*.
..........*....*#.
.#................
......#...........
.........#..#.....
..........#..*....
13 1
17 8
0 0
0 17
8 17
15 15
10 10
17 17
9 15
5 5

出力例2
******************
.*..**.*.**.#.#.*#
..*..****#.....*..
..#*.*.*#.....*...
...#***......*....
.************.*..*
#...***........*..
...*.*.*........*#
..#..*..*.********
.....*...*********
.....*************
#....*...***.....*
.#...*..*...*...**
.**********..*.*#*
.#......*.....**.*
......#.********.*
........*#..#.*.**
........*.#..*****
"""

H, W, N = map(int, input().split())
s = [list(input()) for _ in range(H)]
points = [list(map(int, input().split())) for _ in range(N)]


def check_diagonal(x, y, s):
    for lr1 in range(-1, 2, 2):
        for lr2 in range(-1, 2, 2):
            i = 0
            while True:
                i += 1
                if (
                    x + i * lr1 < 0
                    or x + i * lr1 >= W
                    or y + i * lr2 < 0
                    or y + i * lr2 >= H
                ):
                    break
                if s[y + i * lr2][x + i * lr1] == "*":
                    for j in range(1 + i):
                        s[y + j * lr2][x + j * lr1] = "*"
                    break
                if s[y + i * lr2][x + i * lr1] == "#":
                    break


def check_row(x, y, s):
    for lr in range(-1, 2, 2):
        i = 0
        while True:
            i += 1
            if x + i * lr < 0 or x + i * lr >= W:
                break
            if s[y][x + i * lr] == "*":
                for j in range(1 + i):
                    s[y][x + j * lr] = "*"
                break
            if s[y][x + i * lr] == "#":
                break


def check_column(x, y, s):
    for lr in range(-1, 2, 2):
        i = 0
        while True:
            i += 1
            if y + i * lr < 0 or y + i * lr >= H:
                break
            if s[y + i * lr][x] == "*":
                for j in range(1 + i):
                    s[y + j * lr][x] = "*"
                break
            if s[y + i * lr][x] == "#":
                break


for y, x in points:
    s[y][x] = "*"
    check_row(x, y, s)
    check_column(x, y, s)
    check_diagonal(x, y, s)

for y in range(H):
    for x in range(W):
        print(s[y][x], end="")
    print()